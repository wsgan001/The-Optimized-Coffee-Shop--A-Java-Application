package p2;

import java.util.HashSet;
import java.util.List;

import p2.SimulationEvent;


/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static boolean check(boolean check, String message) {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			return false;
		}
		return true;
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	
	/*INVARIANTS:
	 * 1. Every simulated event generated by the simulator must go through validation and 
	 * should be valid to be processed.
	 * 
	 *PRE-CONDITIONS:
	 * 1. List of events generated by simulator must be validated in the order in which they were generated.
	 * 2. Coffee shop capacity, number of tables, number of cooks, machine capacity must be defined
	 * 
	 *POST-CONDITIONS:
	 * 1. Boolean value indicating the validity of simulated events will be returned.
	 * 
	 *EXCEPTIONS:
	 *InvalidSimulationException will be thrown if list of events smulated are found to be invalid. 
	 */
	
	public static boolean validateSimulation(List<SimulationEvent> events, int numCustomers, int numCooks, int numTables, int machineCapacity) {
		
		boolean testFailed = true;
		check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
				"Simulation didn't start with initiation event");
		check(events.get(events.size()-1).event == 
				SimulationEvent.EventType.SimulationEnded,
				"Simulation didn't end with termination event");

		// In P2 you will write validation code for things such as:
		//	Should not have more eaters than specified
		testFailed = check(eaterCountCheck(events, numCustomers),
			"Number of eaters exceeded number of customers specified") && testFailed;
			
		//	Should not have more cooks than specified
		testFailed = check(cookCountCheck(events, numCooks),
				"Number of cooks exceeded number of cooks specified") && testFailed;
			
		//	The coffee shop capacity should not be exceeded
		testFailed = check(restaurantCapacityCheck(events, numTables),
				"Number of customers exceeded number of tables") && testFailed;
			
		//	The capacity of each machine should not be exceeded
		testFailed = machineCapacityCheck(events, machineCapacity) && testFailed;
			
		//	Eater should not receive order until cook completes it
		testFailed = check(cookCompletesBeforeCustomerReceives(events, numCustomers),
				"Eaters received order before cook completed it") && testFailed;
		
			
		//	Eater should not leave coffee shop until order is received
		testFailed = check(customerLeaveTest(events, numCustomers),
				"Eaters left the shop before receiving their orders") && testFailed;
			
		//	Eater should not place more than one order
		testFailed = check(noOfOrdersPerCustomerCheck(events, numCustomers),
				"Customers placed more than one order per head") && testFailed;
			
		//	Cook should not work on order before it is placed
			

		return testFailed;
	}

	
	private static boolean noOfOrdersPerCustomerCheck(List<SimulationEvent> events, int numCustomers) {
		boolean result = true;
		int currentCustomerOrders = 0;
	
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.CustomerPlacedOrder) {
				currentCustomerOrders++;
			}
			if (currentCustomerOrders > numCustomers) {
				result = false;
			}
		}
		
		return result;
	}

	private static boolean eaterCountCheck(List<SimulationEvent> events, int numCustomers) {
		boolean result = true;
		int currentEaters = 0;
		// Max Eaters Test
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.CustomerReceivedOrder) {
				currentEaters++;
			}
			if (currentEaters > numCustomers) {
				result = false;
			}
		}
		return result;
}
	
	private static boolean restaurantCapacityCheck(List<SimulationEvent> events, int numTables) {
			boolean result = true;
			int currentCustomers = 0;
			// Max Customers Test
			for (SimulationEvent e : events) {
				if (e.event == SimulationEvent.EventType.CustomerPlacedOrder) {
					currentCustomers++;
				}
				if (e.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
					currentCustomers--;
				}
				if (currentCustomers > numTables) {
					result = false;
				}
			}

			return result;
  }
	
	private static boolean cookCountCheck(List<SimulationEvent> events, int numCooks) {
		boolean result = true;
		int currentCooks = 0;
		// Max Cooks Test
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.CookStarting) {
				currentCooks++;
			}
			if (currentCooks > numCooks) {
				result = false;
			}
		}
		return result;
}
	
	private static boolean machineCapacityCheck(List<SimulationEvent> events,
			int machineCapacity) {
		boolean checkBurgers = true;
		int noOfBurgers = 0;
		boolean checkFries = true;
		int noOfFries = 0;
		boolean checkCoffees = true;
		int noOfCoffees = 0;
		// Machine Capacity Test
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.MachineStartingFood) {
				if (e.machine.machineName.equals("MachineGrill")) {
					noOfBurgers++;
				} else if (e.machine.machineName.equals("MachineFrier")) {
					noOfFries++;
				} else if (e.machine.machineName.equals("CoffeeMaker2000")) {
					noOfCoffees++;
				}
			}
			if (e.event == SimulationEvent.EventType.MachineDoneFood) {
				if (e.machine.machineName.equals("MachineGrill")) {
					noOfBurgers--;
				} else if (e.machine.machineName.equals("MachineFrier")) {
					noOfFries--;
				} else if (e.machine.machineName.equals("CoffeeMaker2000")) {
					noOfCoffees--;
				}
			}
			if (noOfBurgers > machineCapacity) {
				checkBurgers = false;
			}
			if (noOfFries > machineCapacity) {
				checkFries = false;
			}
			if (noOfCoffees > machineCapacity) {
				checkCoffees = false;
			}
		}
		return check(checkBurgers, "Exceeded grill capacity")
				&& check(checkFries, "Exceeded frier capacity")
				&& check(checkCoffees, "Exceeded coffee maker capacity");
	}

	private static boolean cookCompletesBeforeCustomerReceives(
			List<SimulationEvent> events, int numOrders) {
		boolean[] customersThatReceivedOrder = new boolean[numOrders+1];
		boolean[] ordersThatCookCompleted = new boolean[numOrders+1];
		boolean result = true;
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.CustomerReceivedOrder) {
				int order = e.orderNumber;
				customersThatReceivedOrder[order] = true;
				if (customersThatReceivedOrder[order] && !ordersThatCookCompleted[order]) {
					result = false;
				}
			}
			if (e.event == SimulationEvent.EventType.CookCompletedOrder) {
				int order = e.orderNumber;
				ordersThatCookCompleted[order] = true;
			}
		}
		return result;
	}

	
	private static boolean customerLeaveTest(List<SimulationEvent> events,
			int numCustomers) {
		// Customer should not leave coffee shop until order is received test
		int orderReceivedIndex = 0;
		int customerLeftIndex = 0;
		for (int i = 0; i < numCustomers; i++) {
			for (int j = 0; j < events.size(); j++) {
				if (events.get(j).toString().contains("Customer " + i)) {
					if (events.get(j).event == SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
						customerLeftIndex = j;
					}
					if (events.get(j).event == SimulationEvent.EventType.CustomerReceivedOrder) {
						orderReceivedIndex = j;
					}
				}
			}
			if (orderReceivedIndex > customerLeftIndex) {
				return false;
			}
		}
		return true;
	}

	 private static boolean customerBeforeCookOrders(List<SimulationEvent> events) {
	        HashSet<Integer> set = new HashSet<Integer>();
	        boolean passed = true;

	        for (SimulationEvent event : events) {
	            if (event.event == SimulationEvent.EventType.CustomerPlacedOrder) {
	                set.add(event.orderNumber);
	            }
	            if (event.event == SimulationEvent.EventType.CookReceivedOrder) {
	                if (!set.contains(event.orderNumber)) {
	                    passed = false;
	                }
	            }

	        }
	        return passed;
	    }

	
}
